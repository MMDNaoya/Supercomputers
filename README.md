現在利用可能なスーパーコンピュータとその利用法について説明する

# 利用可能ノード一覧

<table>
  <thead>
    <tr>
      <th>所属/施設</th>
      <th>システム名 + ノード種別</th>
      <th>CPU</th>
      <th>メモリ</th>
      <th>GPU</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2"><a href="https://mdcl.issp.u-tokyo.ac.jp/scc/system/systembinfo">物性研 SYSTEM B otaka</a></td>
      <td>CPUノード</td>
      <td>AMD EPYC 7702（64コア×2）</td>
      <td>256 GB</td>
      <td>なし</td>
    </tr>
    <tr>
      <td>Fatノード</td>
      <td>Intel Xeon Platinum 8280（28コア×4）</td>
      <td>3 TB</td>
      <td>なし</td>
    </tr>
    <tr>
      <td rowspan="2"><a href="https://mdcl.issp.u-tokyo.ac.jp/scc/system/newsystemc">物性研 SYSTEM C kugui</a></td>
      <td>CPUノード</td>
      <td>AMD EPYC 7763（64コア×2）</td>
      <td>256 GB</td>
      <td>なし</td>
    </tr>
    <tr>
      <td>ACCノード</td>
      <td>AMD EPYC 7763（64コア）</td>
      <td>256 GB</td>
      <td>NVIDIA A100 GPU（40 GB×4）</td>
    </tr>
    <tr>
      <td rowspan="2"><a href="https://www.cc.u-tokyo.ac.jp/supercomputer/miyabi/service/">情報基盤センター MIYABI(準備中)</a></td>
      <td>Miyabi-C ノード</td>
      <td>Intel Xeon Max 9480（56コア×2）</td>
      <td>128 GiB</td>
      <td>なし</td>
    </tr>
    <tr>
      <td>Miyabi-G ノード</td>
      <td>NVIDIA Grace CPU（72コア）</td>
      <td>120 GB</td>
      <td>NVIDIA Hopper H100 GPU（96 GB）</td>
    </tr>
  </tbody>
</table>

# スーパーコンピュータの使い方概説
## スーパーコンピュータのノードの種類

スーパーコンピュータは多数の計算ノード（Compute Node）で構成され，ログインノード（Login Node）と実行ノード（Compute Node） の2種類がある．
ログインノードからジョブスケジューラにバッチを投入し，ジョブスケジューラが計算を実行ノードに割り当てる．

### ログインノード
- シェル操作，スクリプト作成，ジョブ送信（ジョブスケジューラ操作)，データ送受信などを行う
- 多くの利用者が同時に利用するので，CPUやメモリを独占するような計算は行わない---当局から**厳しい指導**が入る可能性

### 実行ノード (計算ノード)
- ジョブスケジューラ（例：Slurm）を通して実際の計算を行う
- 計算時間や使用ノード数はジョブスケジューラで制御される
- 基本的にユーザがsshログインなどすることはない

## ジョブについて
スーパーコンピュータでいうジョブとは，ユーザーが実行したい計算処理やシミュレーションを，ジョブスケジューラに投入する単位である．  
ジョブは，計算機上で直接実行するのではなく，ジョブスケジューラを介して実行ノードに割り当てられる．これにより，多数の利用者が同時にシステムを利用しても，資源の競合を避けて効率的に計算を行うことができる．
ジョブスケジューラはジョブの指定に応じて複数のノードを並列動作させるなども行う．例えばMiyabi-Gは96GBメモリのGPU1枚しか持たないので，よりGPUメモリを必要とする計算をする際はその分のノードを並列して計算する．
ジョブの情報はジョブスクリプトというファイルに書き，それをジョブ投入コマンドでジョブスケジューラに投入する．
ジョブ投入コマンドはシステムによって異なるので，各システムのマニュアルを参照すること．


### ジョブに書くべき内容
- **実行するプログラムやスクリプトのパス**  
  - どの計算プログラムを実行するかを指定する．  
  - 例：`./my_simulation.x input.dat`  
- **入力ファイルやデータのパス**  
  - 計算に必要なデータや設定ファイルの場所を指定する．  
- **出力ファイルの保存先**  
  - 計算結果やログをどこに書き出すかを指定する．  
- **計算前の環境設定**  
  - モジュールのロードや環境変数の設定など．  
  - 例：`module load gcc/12.2.0`  
- **必要に応じた前処理や後処理**  
  - データの整形や計算後の整理などもジョブスクリプトに含められる．

### ジョブを投入する際に考慮すべきこと
- **計算規模の見積もり**  
  - 使用するノード数、CPUコア数、メモリ量、GPUの有無、計算時間などを適切に見積もる必要がある．  
  - 見積もりが不正確だと，ジョブが長時間待たされたり，途中で強制終了されることがある．
  - ジョブ実行ではノード種別・ノード数・稼働時間に応じてポイントを消費する．ポイントを使い切ると研究室全体でスパコンを使えなくなるため，必要最小限の構成でジョブを実行すること．
- **並列計算の管理**  
  - MPIやOpenMPなどの並列化方式に応じて，プロセス数やスレッド数を設定する必要がある．
- **ログ管理**  
  - 標準出力や標準エラー出力のファイル名を設定し，計算結果やエラー内容を追跡できるようにする．
  - インタラクティブノードを使うと，計算ノードと同じ環境で対話的にデバッグできる

### 注意事項
- otakaおよびkuguiでは，ファイルをおいておくだけでポイントが消費される．1ポイント/(TB・日)なので，研究室全員の合計のファイル容量が1TBだとそれだけで100日間で割当ポイント(100P)を使い切る．そのため必要なときにだけデータをアップロードし，計算が完了したらすぐに結果をダウンロード・削除するなど省容量化に努力すること．
- ログインノードでは本格的な計算をしないこと
